// Code generated by Stan version 2.14

#ifndef VIFCOPULA_BICOPULA_HPP
#define VIFCOPULA_BICOPULA_HPP

#include <stan/model/model_header.hpp>
#include <dist/bicop_log.hpp>
#include <extra/goodman_kruskal_gamma.hpp>
#include <service/write_theta.hpp>

namespace vifcopula
{

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;
using namespace vifcopula;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

//static int current_statement_begin__;

class bicopula : public prob_grad
{
private:
    int t_max;                           // Number of periods
    vector<double> u;                 // bicopula first vector data
    vector<double> v;                 // bicopula second vector data
    int copula_type;                    // copula type

public:

    ~bicopula() { }

    bicopula(int copula_type_,
             const vector<double>& u_, const vector<double>& v_,
             int t_max_,
             std::ostream* pstream__ = 0)
        : prob_grad(0)
    {
        typedef boost::ecuyer1988 rng_t;
        rng_t base_rng(0);  // 0 seed default
        bicopula(copula_type_,u_, v_,
                 t_max_, base_rng, pstream__);
    }

    template <class RNG>
    bicopula(int copula_type_,
             const vector<double>& u_, const vector<double>& v_,
             const int& t_max_,
             RNG& base_rng__,std::ostream* pstream__ = 0)
        : prob_grad(0), u(u_), v(v_),copula_type(copula_type_),
          t_max(t_max_)
    {
        static const char* function = "vifcopula::bicopula";

        num_params_r__ = 0U;
        param_ranges_i__.clear();
        num_params_r__ += 1;
        if (copula_type == 0)
        {
            num_params_r__ --;
        }
        else if (copula_type == 2)
        {
            num_params_r__ ++;
        }
    }

    void set_v(const vector<double>& v_){
        v = v_;
    }
    void set_u(const vector<double>& u_){
        u = u_;
    }
    void set_copula_type(int copula_type_){
        copula_type = copula_type_;

        num_params_r__ = 0U;
        param_ranges_i__.clear();
        num_params_r__ += 1;
        if (copula_type == 0)
        {
            num_params_r__ --;
        }
        else if (copula_type == 2)
        {
            num_params_r__ ++;
        }

    }
    void reset(int copula_type_,
               const vector<double>& u_,
               const vector<double>& v_){
        copula_type = copula_type_;
        u = u_;
        v = v_;

        num_params_r__ = 0U;
        param_ranges_i__.clear();
        num_params_r__ += 1;
        if (copula_type == 0)
        {
            num_params_r__ --;
        }
        else if (copula_type == 2)
        {
            num_params_r__ ++;
        }
    }
    // return True if the copula is independent
    bool check_Ind(void){

        int concordant, discordant, extraX, extraY, spare;
        std::vector<size_t> order_U = sort_indexes(u);

        // reorder X and Y
        std::vector<double> U_ord(t_max);
        std::vector<double> V_ord(t_max);
        for(int i = 0; i != t_max; ++i)
          U_ord[i] = u[order_U[i]];
        for(int i = 0; i != t_max; ++i)
          V_ord[i] = v[order_U[i]];

        // sort Y for equal values of X
        secondary_sort(U_ord.begin(), U_ord.end(), V_ord.begin(), V_ord.end());

        // calculate result
        concordance_count(U_ord.begin(), U_ord.end(), V_ord.begin(), V_ord.end(),
		      concordant, discordant, extraX, extraY, spare);

        double tau = kendall_tau(concordant, discordant, extraX, extraY);
        double f_stat = sqrt((9 * t_max * (t_max - 1))/(2 * (2 * t_max + 5))) * abs(tau);
        boost::math::normal s;
        double p_value = 2 * (1 - cdf(s,f_stat));
        return( (p_value > 0.05) );
    }



    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const
    {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        static int current_statement_begin__;

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        // model parameters
        stan::io::reader<T__> in__(params_r__,params_i__);

        Eigen::Matrix<T__,Eigen::Dynamic,1>  theta(1);
        (void) theta;  // dummy to suppress unused var warning

        Eigen::Matrix<T__,Eigen::Dynamic,1>  theta2(1);
        (void) theta2;  // dummy to suppress unused var warning


        // model body
        try
        {

            current_statement_begin__ = 14;
            // initial
            int i = 0;
            std::vector<int> cop_vec(1);
            cop_vec[0] = copula_type;
            Eigen::Matrix<double,Eigen::Dynamic,1> u_temp(t_max);
            Eigen::Matrix<double,Eigen::Dynamic,1> v_temp(t_max);
            u_temp = Eigen::VectorXd::Map(&u[0], t_max);
            v_temp = Eigen::VectorXd::Map(&v[0], t_max);

            bicop_log_add<propto__,jacobian__,double, double, T__>(i, cop_vec, u_temp, v_temp, theta, theta2, lp__, lp_accum__, in__);

            // switch ( copula_type )
            // {
            // case 0:
            //     // Independence copula
            //     current_statement_begin__ = 15;
            //     //theta = in__.scalar_constrain();
            //     theta = 0;
            //     lp_accum__.add(bicop_independence_log<propto__>(u,v));
            //     break;
            // case 1:
            //     // Gaussian copula
            //     current_statement_begin__ = 16;
            //     if (jacobian__)
            //         theta = in__.scalar_lub_constrain(0,1,lp__);
            //     else
            //         theta = in__.scalar_lub_constrain(0,1);
            //
            //     lp_accum__.add(uniform_lpdf(theta, 0, 1));
            //     lp_accum__.add(bicop_normal_log<propto__>(u,v,theta));
            //     break;
            // case 2:
            //     // Student copula
            //     current_statement_begin__ = 17;
            //     if (jacobian__)
            //         theta = in__.scalar_lub_constrain(0,1,lp__);
            //     else
            //         theta = in__.scalar_lub_constrain(0,1);
            //
            //
            //     if (jacobian__)
            //         theta2 = in__.scalar_lub_constrain(2,30,lp__);
            //     else
            //         theta2 = in__.scalar_lub_constrain(2,30);
            //
            //     lp_accum__.add(uniform_lpdf(theta, 0, 1));
            //     lp_accum__.add(bicop_student_log<propto__>(u,v,theta,theta2));
            //     break;
            // case 3:
            //     // Clayon copula
            //     current_statement_begin__ = 18;
            //     if (jacobian__)
            //         theta = in__.scalar_lub_constrain(0.001,30,lp__);
            //     else
            //         theta = in__.scalar_lub_constrain(0.001,30);
            //
            //     //lp_accum__.add(uniform_lpdf<propto__>(theta, 0, Inf)); //Improper priors
            //     lp_accum__.add(bicop_clayton_log<propto__>(u,v,theta));
            //     break;
            // case 4:
            //     // Gumbel copula
            //     current_statement_begin__ = 19;
            //     if (jacobian__)
            //         theta = in__.scalar_lub_constrain(1,20,lp__);
            //     else
            //         theta = in__.scalar_lub_constrain(1,20);
            //
            //     //lp_accum__.add(uniform_lpdf<propto__>(theta, 1, Inf)); //Improper priors
            //     lp_accum__.add(bicop_gumbel_log<propto__>(u,v,theta));
            //     break;
            // case 5:
            //     // Frank copula
            //     current_statement_begin__ = 20;
            //     if (jacobian__)
            //         theta = in__.scalar_lub_constrain(0,20,lp__);
            //     else
            //         theta = in__.scalar_lub_constrain(0,20);
            //
            //     //lp_accum__.add(uniform_lpdf<propto__>(theta, 0, Inf)); //Improper priors
            //     lp_accum__.add(bicop_frank_log<propto__>(u,v,theta));
            //     break;
            // case 6:
            //     // Joe copula
            //     current_statement_begin__ = 21;
            //     if (jacobian__)
            //         theta = in__.scalar_lub_constrain(1,50,lp__);
            //     else
            //         theta = in__.scalar_lub_constrain(1,50);
            //
            //     //lp_accum__.add(uniform_lpdf<propto__>(theta, 0, Inf)); //Improper priors
            //     lp_accum__.add(bicop_joe_log<propto__>(u,v,theta));
            //     break;
            // default:
            //     // Code to execute if <variable> does not equal the value following any of the cases
            //     // Send a break message.
            //     break;
            // }




        }
        catch (const std::exception& e)
        {
            // stan::lang::rethrow_located(e,current_statement_begin__);
            // Next line prevents compiler griping about no return
            throw std::runtime_error(" ");
        }
        //std::cout << " End_of_log_prob " << theta << std::endl;

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                std::ostream* pstream = 0) const
    {
        std::vector<T_> vec_params_r;
        vec_params_r.reserve(params_r.size());
        for (int i = 0; i < params_r.size(); ++i)
            vec_params_r.push_back(params_r(i));
        std::vector<int> vec_params_i;
        return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const
    {

        names__.resize(0);

        if (copula_type > 0) names__.push_back("theta");
        if (copula_type == 2) names__.push_back("theta2");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const
    {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        if (copula_type > 0)
        {
            dims__.resize(0);
            dimss__.push_back(dims__);
        }

        if (copula_type == 2)
        {
            dims__.resize(0);
            dimss__.push_back(dims__);
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const
    {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "vifcopula::write_array";
        (void) function__; // dummy call to supress warning

        write_theta(copula_type, in__, vars__);

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__; // dummy call to supress warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning


        // validate transformed parameters

        // write transformed parameters


        if (!include_gqs__) return;
        // declare and define generated quantities


        // try
        // {
        // }
        // catch (const std::exception& e)
        // {
        //     stan::lang::rethrow_located(e,current_statement_begin__);
        //     // Next line prevents compiler griping about no return
        //     throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        // }

        // validate generated quantities

        // write generated quantities
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const
    {
        std::vector<double> params_r_vec(params_r.size());
        for (int i = 0; i < params_r.size(); ++i)
            params_r_vec[i] = params_r(i);
        std::vector<double> vars_vec;
        std::vector<int> params_i_vec;
        write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
        vars.resize(vars_vec.size());
        for (int i = 0; i < vars.size(); ++i)
            vars(i) = vars_vec[i];
    }

    static std::string model_name()
    {
        return "bicopula";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const
    {
        std::stringstream param_name_stream__;
        if (copula_type > 0)
        {
            param_name_stream__.str(std::string());
            param_name_stream__ << "theta";
            param_names__.push_back(param_name_stream__.str());
        }

        if (copula_type == 2)
        {
            param_name_stream__.str(std::string());
            param_name_stream__ << "theta2";
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__) return;
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const
    {
        std::stringstream param_name_stream__;
        if (copula_type > 0)
        {
            param_name_stream__.str(std::string());
            param_name_stream__ << "theta";
            param_names__.push_back(param_name_stream__.str());
        }

        if (copula_type == 2)
        {
            param_name_stream__.str(std::string());
            param_name_stream__ << "theta2";
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;

        if (!include_gqs__) return;
    }

}; // model

} // namespace

//typedef vifcopula::bicopula stan_model;

#endif // VIFCOPULA_BICOPULA_HPP
